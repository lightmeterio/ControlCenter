// SPDX-FileCopyrightText: 2021 Lightmeter <hello@lightmeter.io>
// SPDX-FileCopyrightText: 2021 Lightmeter <hello@lightmeter.io>
//
// SPDX-License-Identifier: AGPL-3.0-only

package localrblinsight

import (
	"context"
	"database/sql"
	"errors"
	"github.com/rs/zerolog/log"
	"gitlab.com/lightmeter/controlcenter/i18n/translator"
	"gitlab.com/lightmeter/controlcenter/insights/core"
	"gitlab.com/lightmeter/controlcenter/localrbl"
	notificationCore "gitlab.com/lightmeter/controlcenter/notification/core"
	"gitlab.com/lightmeter/controlcenter/settings/globalsettings"
	"gitlab.com/lightmeter/controlcenter/util/errorutil"
	"gitlab.com/lightmeter/controlcenter/util/timeutil"
	"net"
	"time"
)

type Options struct {
	Checker                     localrbl.Checker
	CheckInterval               time.Duration
	RetryOnScanErrorInterval    time.Duration
	MinTimeToGenerateNewInsight time.Duration
}

type Content struct {
	ScanInterval timeutil.TimeInterval     `json:"scan_interval"`
	Address      net.IP                    `json:"address"`
	RBLs         []localrbl.ContentElement `json:"rbls"`
}

func (c Content) Title() notificationCore.ContentComponent {
	return &title{c}
}

func (c Content) Description() notificationCore.ContentComponent {
	return &description{c}
}

func (c Content) Metadata() notificationCore.ContentMetadata {
	return nil
}

type title struct {
	c Content
}

func (t title) String() string {
	return translator.Stringfy(t)
}

func (t title) TplString() string {
	return translator.I18n("IP on shared blocklist")
}

func (t title) Args() []interface{} {
	return nil
}

type description struct {
	c Content
}

func (d description) String() string {
	return translator.Stringfy(d)
}

func (d description) TplString() string {
	return translator.I18n("The IP address %v is listed by %v RBLs")
}

func (d description) Args() []interface{} {
	return []interface{}{d.c.Address, len(d.c.RBLs)}
}

func (c Content) HelpLink(urlContainer core.URLContainer) string {
	return urlContainer.Get(ContentType)
}

const (
	ContentType   = "local_rbl_check"
	ContentTypeId = 4
)

var decodeContent = core.DefaultContentTypeDecoder(&Content{})

func init() {
	core.RegisterContentType(ContentType, ContentTypeId, core.DefaultContentTypeDecoder(&Content{}))
}

type detector struct {
	options Options
	creator core.Creator
}

func (d *detector) Close() error {
	return d.options.Checker.Close()
}

func getDetectorOptions(options core.Options) Options {
	detectorOptions, ok := options["localrbl"].(Options)

	if !ok {
		errorutil.MustSucceed(errors.New("Invalid detector options"))
	}

	return detectorOptions
}

func NewDetector(creator core.Creator, options core.Options) core.Detector {
	detectorOptions := getDetectorOptions(options)

	return &detector{
		options: detectorOptions,
		creator: creator,
	}
}

func shouldGenerateBasedOnHistoricalDataAndCurrentResults(ctx context.Context, d *detector, r localrbl.Results, c core.Clock, tx *sql.Tx) (bool, error) {
	now := c.Now()

	lookbackTime := now.Add(-d.options.MinTimeToGenerateNewInsight)

	var lastInsightRawContent string

	err := tx.QueryRowContext(ctx, `select
			content
		from
			insights
		where
			time >= ? and content_type = ?
		order by
			time desc
		limit
			1
		`, lookbackTime.Unix(), ContentTypeId).Scan(&lastInsightRawContent)

	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return true, nil
	}

	if err != nil {
		return false, errorutil.Wrap(err)
	}

	v, err := decodeContent([]byte(lastInsightRawContent))
	if err != nil {
		return false, errorutil.Wrap(err)
	}

	if err != nil {
		return false, errorutil.Wrap(err)
	}

	resultChanged := contentsHaveDifferentLists(r.RBLs, v.(*Content).RBLs)

	if !resultChanged {
		log.Info().Msg("RBL Scan result will not generate a new insight as scan results have not changed since last insight")
	}

	return resultChanged, nil
}

// Given two RBL lists, were they generated by different RBLs?
// It assumes the lists are already sorted
func contentsHaveDifferentLists(a, b []localrbl.ContentElement) bool {
	if len(a) != len(b) {
		return true
	}

	for i := range a {
		if a[i].RBL != b[i].RBL {
			return true
		}
	}

	return false
}

func maybeCreateInsightForResult(ctx context.Context, d *detector, r localrbl.Results, c core.Clock, tx *sql.Tx) error {
	shouldGenerate, err := shouldGenerateBasedOnHistoricalDataAndCurrentResults(ctx, d, r, c, tx)

	if err != nil {
		return errorutil.Wrap(err)
	}

	if !shouldGenerate {
		return nil
	}

	return generateInsight(tx, c, d.creator, Content{
		ScanInterval: r.Interval,
		Address:      globalsettings.IPAddress(context.Background()),
		RBLs:         r.RBLs,
	})
}

const (
	detectionKind = "local_rbl_scan_start"
)

func maybeStartANewScan(d *detector, c core.Clock, tx *sql.Tx) error {
	now := c.Now()

	// If it's time, ask the checker to start a new scan
	t, err := core.RetrieveLastDetectorExecution(tx, detectionKind)

	if err != nil {
		return errorutil.Wrap(err)
	}

	if !t.IsZero() && !now.After(t.Add(d.options.CheckInterval)) {
		return nil
	}

	d.options.Checker.NotifyNewScan(now)

	if err := core.StoreLastDetectorExecution(tx, detectionKind, now); err != nil {
		return errorutil.Wrap(err)
	}

	return nil
}

func scheduleANewScanShortly(d *detector, c core.Clock, tx *sql.Tx) error {
	lastExecutedTime := c.Now().Add(d.options.RetryOnScanErrorInterval).Add(-d.options.CheckInterval)

	if err := core.StoreLastDetectorExecution(tx, detectionKind, lastExecutedTime); err != nil {
		return errorutil.Wrap(err)
	}

	return nil
}

func (d *detector) Step(c core.Clock, tx *sql.Tx) error {
	baseCtx := context.Background()

	return d.options.Checker.Step(c.Now(), func(r localrbl.Results) error {
		ctx, cancel := context.WithTimeout(baseCtx, time.Second*2)

		defer cancel()

		if r.Err == nil {
			// a scan result is available
			return maybeCreateInsightForResult(ctx, d, r, c, tx)
		}

		// A scan just ended with an error, schedule a new scan shortly after the current failure
		return scheduleANewScanShortly(d, c, tx)
	}, func() error {
		// no scan result available
		return maybeStartANewScan(d, c, tx)
	})
}

func generateInsight(tx *sql.Tx, c core.Clock, creator core.Creator, content Content) error {
	properties := core.InsightProperties{
		Time:           c.Now(),
		Category:       core.LocalCategory,
		Rating:         core.OkRating,
		ContentType:    ContentType,
		Content:        content,
		MustBeNotified: true,
	}

	if err := creator.GenerateInsight(context.Background(), tx, properties); err != nil {
		return errorutil.Wrap(err)
	}

	return nil
}
